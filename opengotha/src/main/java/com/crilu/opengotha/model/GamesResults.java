package com.crilu.opengotha.model;

import com.crilu.opengotha.Game;
import com.crilu.opengotha.GameComparator;
import com.crilu.opengotha.Gotha;
import com.crilu.opengotha.Match;
import com.crilu.opengotha.Player;
import com.crilu.opengotha.Team;
import com.crilu.opengotha.TournamentInterface;
import com.crilu.opengotha.TournamentPrinting;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class GamesResults {

    public static final int TABLE_NUMBER_COL = 0;
    public static final int LEFT_PLAYER_COL = 1;
    public static final int RIGHT_PLAYER_COL = 2;
    public static final int HANDICAP_COL = 3;
    public static final int RESULT_COL = 4;
    public static final int TABLE_NUMBER_WIDTH = 40;
    public static final int PLAYER_WIDTH = 150;
    public static final int HANDICAP_WIDTH = 20;
    public static final int RESULT_WIDTH = 40;
    private static final long REFRESH_DELAY = 2000;
    private long lastComponentsUpdateTime = 0;
    public int gamesSortType = GameComparator.TABLE_NUMBER_ORDER;
    private int spnRoundNumber;
    private List<Vector<String>> tblGames;

    private List<GamesResultsListener> mCallbacks = new ArrayList<>();

    public interface GamesResultsListener {
        void updateTitle(String title);
        void onMessage(String message);
        void onUpdateTableGames();
    }


    /**
     * current Tournament
     */
    private TournamentInterface tournament;
    /**
     * current Round
     */
    private int processedRoundNumber = 0;

    /**
     * Creates new form JFrPlayerManager
     */
    public GamesResults(TournamentInterface tournament) {
//        LogElements.incrementElement("games.results", "");
        this.tournament = tournament;

        processedRoundNumber = tournament.presumablyCurrentRoundNumber();
        initComponents();
        customInitComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * Unlike initComponents, customInitComponents is editable
     */
    private void customInitComponents() {
        this.updateAllViews();
    }

    private void updateComponents() {
        this.spnRoundNumber = this.processedRoundNumber + 1;

        ArrayList<Game> alCurrentActualGames = null;
        alCurrentActualGames = tournament.gamesList(processedRoundNumber);
        fillGamesTable(alCurrentActualGames);
    }

    private void fillGamesTable(ArrayList<Game> alG) {
        // sort
        ArrayList<Game> alDisplayedGames = new ArrayList<Game>(alG);

        GameComparator gameComparator = new GameComparator(gamesSortType);
        Collections.sort(alDisplayedGames, gameComparator);

        tblGames.clear();

        for (int iG = 0; iG < alDisplayedGames.size(); iG++) {
            Vector<String> row = new Vector<String>();
            Game g = alDisplayedGames.get(iG);
            int col = 0;
            row.add("" + (g.getTableNumber() + 1));
            Player wP = g.getWhitePlayer();
            row.add(wP.fullName());
            Player bP = g.getBlackPlayer();
            row.add(bP.fullName());
            row.add("" + g.getHandicap());
            String strResult = g.resultAsString(true);
            row.add(strResult);

            tblGames.add(row);
        }
        updateTableGames();
    }

    private void fillTeamGamesTable() {
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        updateTitle("Games .. Results");
        tblGames = new ArrayList<>();

    }// </editor-fold>//GEN-END:initComponents

    public void tblGamesMousePressed(int r, int c) {//GEN-FIRST:event_tblGamesMousePressed
        Game g = null;
        int tn = -1;
        try {
            String strTableNumber = "" + tblGames.get(r).get(TABLE_NUMBER_COL);
            tn = Integer.parseInt(strTableNumber) - 1;
            g = tournament.getGame(processedRoundNumber, tn);
        } catch (NumberFormatException ex) {
            return;
        }
        int oldResult = g.getResult();
        int newResult = oldResult;

        boolean wb = true;

        if ((c == LEFT_PLAYER_COL && wb) || (c == RIGHT_PLAYER_COL && !wb)) {
            newResult = Game.RESULT_WHITEWINS;
        } else if ((c == LEFT_PLAYER_COL && !wb) || (c == RIGHT_PLAYER_COL && wb)) {
            newResult = Game.RESULT_BLACKWINS;
        } else if (c == TABLE_NUMBER_COL) {
            newResult = Game.RESULT_UNKNOWN;
        } else if (c == RESULT_COL) {
            if (oldResult == Game.RESULT_UNKNOWN) {
                newResult = Game.RESULT_WHITEWINS;
            } else if (oldResult == Game.RESULT_WHITEWINS) {
                newResult = Game.RESULT_BLACKWINS;
            } else if (oldResult == Game.RESULT_BLACKWINS) {
                newResult = Game.RESULT_EQUAL;
            } else if (oldResult == Game.RESULT_EQUAL) {
                newResult = Game.RESULT_BOTHWIN;
            } else if (oldResult == Game.RESULT_BOTHWIN) {
                newResult = Game.RESULT_BOTHLOSE;
            } else if (oldResult == Game.RESULT_BOTHLOSE) {
                newResult = Game.RESULT_WHITEWINS_BYDEF;
            } else if (oldResult == Game.RESULT_WHITEWINS_BYDEF) {
                newResult = Game.RESULT_BLACKWINS_BYDEF;
            } else if (oldResult == Game.RESULT_BLACKWINS_BYDEF) {
                newResult = Game.RESULT_EQUAL_BYDEF;
            } else if (oldResult == Game.RESULT_EQUAL_BYDEF) {
                newResult = Game.RESULT_BOTHWIN_BYDEF;
            } else if (oldResult == Game.RESULT_BOTHWIN_BYDEF) {
                newResult = Game.RESULT_BOTHLOSE_BYDEF;
            } else if (oldResult == Game.RESULT_BOTHLOSE_BYDEF) {
                newResult = Game.RESULT_UNKNOWN;
            }
        }

        if (newResult == oldResult) {
            return;
        }
        tournament.setResult(g, newResult);
        this.tournamentChanged();

    }//GEN-LAST:event_tblGamesMousePressed

    private void btnPrintActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPrintActionPerformed
        TournamentPrinting.printGamesList(tournament, processedRoundNumber);
    }//GEN-LAST:event_btnPrintActionPerformed

    private void spnRoundNumberStateChanged() {//GEN-FIRST:event_spnRoundNumberStateChanged
        int demandedRN = spnRoundNumber - 1;
        this.demandedDisplayedRoundNumberHasChanged(demandedRN);
    }//GEN-LAST:event_spnRoundNumberStateChanged

    private void btnHelpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnHelpActionPerformed
        Gotha.displayGothaHelp("Games Results frame");
    }//GEN-LAST:event_btnHelpActionPerformed

    private void ckbTeamOrderActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ckbTeamOrderActionPerformed
        this.updateAllViews();
    }//GEN-LAST:event_ckbTeamOrderActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    private void tournamentChanged() {
        tournament.setLastTournamentModificationTime(tournament.getCurrentTournamentTime());

        updateAllViews();
    }

    private void updateAllViews() {
        if (!tournament.isOpen()) {
            sendMessage("No tournament opened");
        }
        this.lastComponentsUpdateTime = tournament.getCurrentTournamentTime();
        updateTitle("Games .. Results. " + tournament.getFullName());


        int nbRounds = Gotha.MAX_NUMBER_OF_ROUNDS;
        nbRounds = tournament.getTournamentParameterSet().getGeneralParameterSet().getNumberOfRounds();

        if (this.processedRoundNumber >= nbRounds) {
            sendMessage("The number of rounds has been modified."
                            + "\n" + "Current round will be consequently changed");
            this.processedRoundNumber = nbRounds - 1;
        }

        updateComponents();
    }

    private void demandedDisplayedRoundNumberHasChanged(int demandedRN) {
        int numberOfRounds = 0;
        numberOfRounds = tournament.getTournamentParameterSet().getGeneralParameterSet().getNumberOfRounds();

        if (demandedRN < 0 || demandedRN >= numberOfRounds) {
            spnRoundNumber = processedRoundNumber + 1;
            return;
        }
        if (demandedRN == processedRoundNumber) {
            return;
        }

        processedRoundNumber = demandedRN;
        updateAllViews();
    }

    // finds the
    /**
     * finds g, the game at tn table number and rn round number finds m, the
     * match containing g if white player of g is member of black team in m
     * match, returns false else return true
     *
     * @param rn round number
     * @param tn table number
     * @return
     */
    private boolean wbOrder(int rn, int tn) {
        Game g = null;
        Player wP = null;
        Match m = null;
        Team bT = null;
        g = tournament.getGame(rn, tn);
        if (g == null) {
            return true;
        }
        wP = g.getWhitePlayer();
        if (wP == null) return true;
        m = tournament.getMatch(rn, tn);
        if (m == null) return true;
        bT = m.getBlackTeam();

        int bn = bT.boardNumber(rn, wP);
        if (bn >= 0) {
            return false;
        }
        return true;

    }

    public void setSpnRoundNumber(int spnRoundNumber) {
        this.spnRoundNumber = spnRoundNumber;
        spnRoundNumberStateChanged();
    }

    public List<Vector<String>> getTblGames() {
        return tblGames;
    }

    public boolean addGamesResultsListener(GamesResultsListener listener) {
        return mCallbacks.add(listener);
    }

    public boolean removeGamesResultsListener(GamesResultsListener listener) {
        return mCallbacks.remove(listener);
    }

    private void updateTitle(String title) {
        for (GamesResultsListener callback : mCallbacks) {
            callback.updateTitle(title);
        }
    }

    private void sendMessage(String message) {
        for (GamesResultsListener callback : mCallbacks) {
            callback.onMessage(message);
        }
    }

    private void updateTableGames() {
        for (GamesResultsListener callback : mCallbacks) {
            callback.onUpdateTableGames();
        }
    }

}
